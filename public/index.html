<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Assistant with Function Calling</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container { 
      max-width: 800px; 
      width: 100%;
      background: #fff; 
      border-radius: 20px; 
      box-shadow: 0 20px 40px rgba(0,0,0,0.1); 
      padding: 2.5em; 
      text-align: center;
    }

    .header {
      margin-bottom: 30px;
    }

    .header h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 2.5rem;
      font-weight: 700;
    }

    .header p {
      color: #666;
      font-size: 1.2rem;
      margin-bottom: 20px;
    }

    .features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
    }

    .feature {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #007bff;
    }

    .feature h3 {
      color: #333;
      font-size: 1rem;
      margin-bottom: 5px;
    }

    .feature p {
      color: #666;
      font-size: 0.9rem;
    }

    .status { 
      margin-bottom: 25px; 
      min-height: 60px;
      color: #333;
      font-weight: 600;
      padding: 20px;
      background: #e9ecef;
      border-radius: 12px;
      font-size: 1.1em;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .status.connected {
      background: linear-gradient(135deg, #d4edda, #c3e6cb);
      color: #155724;
      border: 2px solid #b8daff;
    }

    .status.processing {
      background: linear-gradient(135deg, #fff3cd, #ffeaa7);
      color: #856404;
      border: 2px solid #f0c674;
    }

    .status.error {
      background: linear-gradient(135deg, #f8d7da, #f5c6cb);
      color: #721c24;
      border: 2px solid #f1b0b7;
    }

    .log { 
      height: 350px; 
      overflow-y: auto; 
      background: #f8f9fa; 
      border-radius: 12px; 
      padding: 20px; 
      margin-bottom: 25px; 
      font-size: 0.95em;
      border: 2px solid #e9ecef;
      text-align: left;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    .log::-webkit-scrollbar {
      width: 8px;
    }

    .log::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .log::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 4px;
    }

    .log::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }

    .log-entry {
      margin: 8px 0;
      padding: 8px 12px;
      border-radius: 6px;
      line-height: 1.4;
    }

    .meta { 
      color: #6c757d; 
      background: #ffffff;
      border-left: 3px solid #6c757d;
    }

    .function-call { 
      color: #28a745; 
      font-weight: bold;
      background: #d4edda;
      border-left: 3px solid #28a745;
    }

    .system { 
      color: #007bff; 
      background: #d1ecf1;
      border-left: 3px solid #007bff;
    }

    .error { 
      color: #dc3545; 
      background: #f8d7da;
      border-left: 3px solid #dc3545;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 25px;
      flex-wrap: wrap;
    }

    button { 
      padding: 15px 30px; 
      font-size: 1.1em; 
      border-radius: 25px; 
      border: none; 
      background: linear-gradient(45deg, #007bff, #0056b3); 
      color: #fff; 
      cursor: pointer; 
      transition: all 0.3s ease;
      font-weight: 600;
      min-width: 160px;
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button:hover:not(:disabled)::before {
      left: 100%;
    }

    button:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 8px 25px rgba(0,123,255,0.4);
    }

    button:active:not(:disabled) {
      transform: translateY(-1px);
    }

    button:disabled { 
      background: linear-gradient(45deg, #6c757d, #5a6268);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .start-btn {
      background: linear-gradient(45deg, #28a745, #20c997);
    }

    .start-btn:hover:not(:disabled) {
      box-shadow: 0 8px 25px rgba(40,167,69,0.4);
    }

    .stop-btn {
      background: linear-gradient(45deg, #dc3545, #c82333);
    }

    .stop-btn:hover:not(:disabled) {
      box-shadow: 0 8px 25px rgba(220,53,69,0.4);
    }

    .examples {
      margin-top: 30px;
      text-align: left;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      border: 2px solid #e9ecef;
    }

    .examples h3 {
      color: #333;
      margin-bottom: 15px;
      text-align: center;
    }

    .examples ul {
      list-style: none;
      padding: 0;
    }

    .examples li {
      background: #fff;
      margin: 8px 0;
      padding: 12px 15px;
      border-radius: 8px;
      border-left: 4px solid #007bff;
      font-style: italic;
      color: #495057;
    }

    .examples li::before {
      content: "üí¨ ";
      margin-right: 8px;
    }

    @media (max-width: 768px) {
      .container {
        margin: 10px;
        padding: 1.5em;
      }

      .header h1 {
        font-size: 2rem;
      }

      .features {
        grid-template-columns: 1fr;
      }

      .controls {
        flex-direction: column;
        align-items: center;
      }

      button {
        width: 100%;
        max-width: 300px;
      }
    }

    .pulse {
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(0, 123, 255, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üìö Document Assistant</h1>
      <p>Ask about company policies, products, or pricing using voice!</p>
    </div>

    <div class="features">
      <div class="feature">
        <h3>üè¢ Company Policies</h3>
        <p>Remote work guidelines and procedures</p>
      </div>
      <div class="feature">
        <h3>üì¶ Product Specs</h3>
        <p>Technical specifications and features</p>
      </div>
      <div class="feature">
        <h3>üí∞ Pricing Info</h3>
        <p>Plans, pricing, and billing details</p>
      </div>
    </div>

    <div class="status" id="status">Click "Start Voice Chat" to begin asking questions!</div>

    <div class="log" id="log">
      <div class="log-entry system">üöÄ Document Assistant Ready</div>
      <div class="log-entry meta">Connect to start voice conversation with document lookup</div>
    </div>

    <div class="controls">
      <button id="startBtn" class="start-btn">üéôÔ∏è Start Voice Chat</button>
      <button id="stopBtn" class="stop-btn" disabled>‚èπÔ∏è Stop Chat</button>
    </div>

    <div class="examples">
    
      <ul>
        
      </ul>
    </div>
  </div>

  <script>
    const logDiv = document.getElementById('log');
    const statusDiv = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    
    let pc, dc, audioEl, running = false;

    function log(msg, cls = "meta") {
      const el = document.createElement("div");
      el.className = `log-entry ${cls}`;
      el.innerHTML = `<span style="color: #999; font-size: 0.8em;">[${new Date().toLocaleTimeString()}]</span> ${msg}`;
      logDiv.appendChild(el);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function setStatus(msg, type = "") {
      statusDiv.textContent = msg;
      statusDiv.className = `status ${type}`;
      
      if (type === "processing") {
        statusDiv.classList.add("pulse");
      } else {
        statusDiv.classList.remove("pulse");
      }
    }

    startBtn.onclick = async () => {
      startBtn.disabled = true;
      stopBtn.disabled = false;
      
      // Clear previous logs but keep initial messages
      logDiv.innerHTML = `
        <div class="log-entry system">üöÄ Document Assistant Starting...</div>
      `;
      
      setStatus("üîÑ Connecting to document assistant...", "processing");

      try {
        // 1. Get ephemeral key from backend
        log("üì° Requesting session from server...");
        const sessionRes = await fetch("/session");
        const session = await sessionRes.json();
        const ephemeralKey = session.ephemeral_key;
        
        if (!ephemeralKey) {
          throw new Error("Failed to get ephemeral key from backend");
        }

        log(`‚úÖ Session created with document lookup enabled`, "system");

        // 2. Set up WebRTC to OpenAI Realtime API
        pc = new RTCPeerConnection();
        dc = pc.createDataChannel("events");

        // Handle events including function calls
        dc.onmessage = async (e) => {
          const msg = JSON.parse(e.data);
          console.log('üì® Received event:', msg.type, msg);
          
          if (msg.type === "session.created") {
            log(`üéØ Document assistant session ready`, "system");
            setStatus("üé§ Connected! Ask about documents...", "connected");
          }
          
          // Handle function calls for document lookup
          if (msg.type === "response.function_call_arguments.done") {
            const functionName = msg.name;
            const functionArgs = msg.arguments;
            const callId = msg.call_id;
            
            log(`üîß Function called: <strong>${functionName}</strong> with query: <em>${JSON.parse(functionArgs).query}</em>`, "function-call");
            setStatus("üìö Searching documents...", "processing");
            
            try {
              // Call our backend function endpoint
              const functionResult = await fetch('/function-call', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  name: functionName,
                  arguments: functionArgs,
                  call_id: callId
                })
              });
              
              const result = await functionResult.json();
              const resultData = JSON.parse(result.output);
              
              if (resultData.documents && resultData.documents.length > 0) {
                const docCount = resultData.documents.length;
                const docTitles = resultData.documents.map(doc => doc.title || 'Document').join(', ');
                log(`üìÑ Found <strong>${docCount}</strong> document(s): ${docTitles}`, "function-call");
              } else {
                log(`üìÑ No documents found for query: "${resultData.query}"`, "function-call");
              }
              
              // Send function result back to OpenAI
              const functionOutput = {
                type: 'conversation.item.create',
                item: {
                  type: 'function_call_output',
                  call_id: callId,
                  output: result.output
                }
              };
              
              dc.send(JSON.stringify(functionOutput));
              dc.send(JSON.stringify({ type: 'response.create' }));
              
              setStatus("ü§ñ AI processing documents...", "processing");
              
            } catch (error) {
              console.error('Function call error:', error);
              log(`‚ùå Function call failed: ${error.message}`, "error");
              setStatus("‚ùå Document search failed", "error");
            }
          }
          
          if (msg.type === "response.audio.delta") {
            // Audio is being generated
            setStatus("üîä AI responding...", "processing");
          }
          
          if (msg.type === "response.done") {
            setStatus("üé§ Listening... Ask about documents!", "connected");
            log(`ü§ñ AI finished responding - ready for next question`, "system");
          }
          
          if (msg.type === "input_audio_buffer.speech_started") {
            setStatus("üëÇ Listening to your question...", "processing");
            log(`üé§ Speech detected - processing...`, "meta");
          }
          
          if (msg.type === "input_audio_buffer.speech_stopped") {
            setStatus("üß† Processing your question...", "processing");
            log(`‚è∏Ô∏è Speech ended - analyzing question...`, "meta");
          }
        };

        // 3. Get microphone and add to peer connection
        log("üé§ Requesting microphone access...");
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            sampleRate: 24000
          } 
        });
        stream.getTracks().forEach(track => pc.addTrack(track, stream));

        log(`üé§ Microphone connected and configured`, "system");

        // 4. Play remote audio from Realtime API
        pc.ontrack = (event) => {
          if (!audioEl) {
            audioEl = document.createElement("audio");
            audioEl.autoplay = true;
            audioEl.volume = 0.8;
            document.body.appendChild(audioEl);
          }
          audioEl.srcObject = event.streams[0];
          log(`üîä AI voice channel connected`, "system");
        };

        // 5. Create offer and send to OpenAI
        log("ü§ù Establishing connection with OpenAI...");
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        const model = "gpt-4o-realtime-preview-2025-06-03";
        const sdpRes = await fetch(`https://api.openai.com/v1/realtime?model=${model}`, {
          method: "POST",
          body: offer.sdp,
          headers: {
            "Authorization": `Bearer ${ephemeralKey}`,
            "Content-Type": "application/sdp"
          }
        });

        if (!sdpRes.ok) {
          throw new Error(`Connection failed: ${sdpRes.status} - ${sdpRes.statusText}`);
        }

        const answer = { type: "answer", sdp: await sdpRes.text() };
        await pc.setRemoteDescription(answer);

        setStatus("üé§ Connected! Ask about company documents!", "connected");
        log(`üöÄ Document assistant ready! Try asking about policies, products, or pricing`, "system");
        running = true;

      } catch (error) {
        console.error("Error starting session:", error);
        setStatus("‚ùå Connection failed - check console", "error");
        log(`‚ùå Error: ${error.message}`, "error");
        startBtn.disabled = false;
        stopBtn.disabled = true;
      }
    };

    stopBtn.onclick = () => {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (audioEl) {
        audioEl.srcObject = null;
        audioEl.remove();
        audioEl = null;
      }
      
      setStatus("‚èπÔ∏è Voice chat stopped");
      log(`‚èπÔ∏è Document assistant session ended`, "system");
      startBtn.disabled = false;
      stopBtn.disabled = true;
      running = false;
    };

    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (pc) {
        pc.close();
      }
    });

    // Handle visibility change (tab switching)
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && audioEl) {
        audioEl.volume = 0.3; // Lower volume when tab is not active
      } else if (audioEl) {
        audioEl.volume = 0.8; // Restore volume when tab is active
      }
    });

    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && e.ctrlKey) {
        e.preventDefault();
        if (!running && !startBtn.disabled) {
          startBtn.click();
        } else if (running && !stopBtn.disabled) {
          stopBtn.click();
        }
      }
    });

    // Add initial help message
    setTimeout(() => {
      log("üí° Tip: Use Ctrl+Space to start/stop the assistant", "meta");
    }, 1000);
  </script>
</body>
</html>
